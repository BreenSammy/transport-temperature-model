// -*- C++ -*-
// File generated by PyFoam - sorry for the ugliness

FoamFile
{
 version 2.0;
 format ascii;
 class dictionary;
 object snappyHexMeshDict;
}

castellatedMesh yes;
snap no;
addLayers no;
geometry
{
  carrier
  {
    type searchableBox;
    min (0.0005 -1.2195 -0.0005);
    max (6.0585 1.2195 2.3855);
  }
  pallet0.stl
  {
    name pallet0;
    type triSurfaceMesh;
  }
  pallet1.stl
  {
    name pallet1;
    type triSurfaceMesh;
  }
  pallet2.stl
  {
    name pallet2;
    type triSurfaceMesh;
  }
  pallet3.stl
  {
    name pallet3;
    type triSurfaceMesh;
  }
  pallet4.stl
  {
    name pallet4;
    type triSurfaceMesh;
  }
  pallet5.stl
  {
    name pallet5;
    type triSurfaceMesh;
  }
} 	// container.stl // {//     type triSurfaceMesh;//     name container;//     // regions//     // {//     //     top//     //     {//     //         name top;//     //     }//     //     bottom//     //     {//     //         name bottom;//     //     }//     //     left//     //     {//     //         name left;//     //     }//     //     right//     //     {//     //         name right;//     //     }//     //     front//     //     {//     //         name front;//     //     }//     //     back//     //     {//     //         name back;//     //     }//     // }// }// Settings for the castellatedMesh generation.

castellatedMeshControls
{
  maxLocalCells 100000;
  maxGlobalCells 5000000; 	// Refinement parameters// ~~~~~~~~~~~~~~~~~~~~~// If local number of cells is >= maxLocalCells on any processor// switches from from refinement followed by balancing// (current method) to (weighted) balancing before refinement.// Overall cell limit (approximately). Refinement will stop immediately// upon reaching this number so a refinement level might not complete.// Note that this is the number of cells before removing the part which// is not 'visible' from the keepPoint. The final number of cells might// actually be a lot less.// The surface refinement loop might spend lots of iterations// refining just a few cells. This setting will cause refinement// to stop if <= minimumRefine are selected for refinement. Note:// it will at least do one iteration (unless the number of cells// to refine is 0)
  minRefinementCells 10; 	// Number of buffer layers between different levels.// 1 means normal 2:1 refinement restriction, larger means slower// refinement.
  nCellsBetweenLevels 1; 	// Explicit feature edge refinement// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// Specifies a level for any cell intersected by its edges.// This is a featureEdgeMesh, read from constant/triSurface for now.
  features
    (
    ); 	// Surface based refinement// ~~~~~~~~~~~~~~~~~~~~~~~~// Specifies two levels for every surface. The first is the minimum level,// every cell intersecting a surface gets refined up to the minimum level.// The second level is the maximum level. Cells that 'see' multiple// intersections where the intersections make an// angle > resolveFeatureAngle get refined up to the maximum level.
  refinementSurfaces
  {
    carrier
    {
      level
        (
          2
          2
        );
    }
    pallet0
    {
      level
        (
          3
          3
        );
    }
    pallet1
    {
      level
        (
          3
          3
        );
    }
    pallet2
    {
      level
        (
          3
          3
        );
    }
    pallet3
    {
      level
        (
          3
          3
        );
    }
    pallet4
    {
      level
        (
          3
          3
        );
    }
    pallet5
    {
      level
        (
          3
          3
        );
    }
  } 	// Surface-wise min and max refinement level// Resolve sharp angles
  resolveFeatureAngle 30; 	// Region-wise refinement// ~~~~~~~~~~~~~~~~~~~~~~// Specifies refinement level for cells in relation to a surface. One of// three modes// - distance. 'levels' specifies per distance to the surface the//   wanted refinement level. The distances need to be specified in//   descending order.// - inside. 'levels' is only one entry and only the level is used. All//   cells inside the surface get refined up to the level. The surface//   needs to be closed for this to be possible.// - outside. Same but cells outside.
  refinementRegions
  {
    carrier
    {
      mode inside;
      levels
        (

          (
            1000000000000000.0
            1
          )
        );
    }
  } 	// Mesh selection// ~~~~~~~~~~~~~~// After refinement patches get added for all refinementSurfaces and// all cells intersecting the surfaces get put into these patches. The// section reachable from the locationInMesh is kept.// NOTE: This point should never be on a face, always inside a cell, even// after refinement.
  locationsInMesh
    49
    (

      (
        (0.205 0.205 2.205)
        airInside
      )

      (
        (0.501 -0.8305 0.344)
        battery0_0
      )

      (
        (1.101 -0.8305 0.344)
        battery0_1
      )

      (
        (0.501 -0.3305 0.344)
        battery0_2
      )

      (
        (1.101 -0.3305 0.344)
        battery0_3
      )

      (
        (0.501 -0.8305 0.744)
        battery0_4
      )

      (
        (1.101 -0.8305 0.744)
        battery0_5
      )

      (
        (0.501 -0.3305 0.744)
        battery0_6
      )

      (
        (1.101 -0.3305 0.744)
        battery0_7
      )

      (
        (0.501 0.3305 0.344)
        battery1_0
      )

      (
        (1.101 0.3305 0.344)
        battery1_1
      )

      (
        (0.501 0.8305 0.344)
        battery1_2
      )

      (
        (1.101 0.8305 0.344)
        battery1_3
      )

      (
        (0.501 0.3305 0.744)
        battery1_4
      )

      (
        (1.101 0.3305 0.744)
        battery1_5
      )

      (
        (0.501 0.8305 0.744)
        battery1_6
      )

      (
        (1.101 0.8305 0.744)
        battery1_7
      )

      (
        (1.901 -0.8305 0.344)
        battery2_0
      )

      (
        (2.501 -0.8305 0.344)
        battery2_1
      )

      (
        (1.901 -0.3305 0.344)
        battery2_2
      )

      (
        (2.501 -0.3305 0.344)
        battery2_3
      )

      (
        (1.901 -0.8305 0.744)
        battery2_4
      )

      (
        (2.501 -0.8305 0.744)
        battery2_5
      )

      (
        (1.901 -0.3305 0.744)
        battery2_6
      )

      (
        (2.501 -0.3305 0.744)
        battery2_7
      )

      (
        (1.901 0.3305 0.344)
        battery3_0
      )

      (
        (2.501 0.3305 0.344)
        battery3_1
      )

      (
        (1.901 0.8305 0.344)
        battery3_2
      )

      (
        (2.501 0.8305 0.344)
        battery3_3
      )

      (
        (1.901 0.3305 0.744)
        battery3_4
      )

      (
        (2.501 0.3305 0.744)
        battery3_5
      )

      (
        (1.901 0.8305 0.744)
        battery3_6
      )

      (
        (2.501 0.8305 0.744)
        battery3_7
      )

      (
        (3.301 -0.8305 0.344)
        battery4_0
      )

      (
        (3.901 -0.8305 0.344)
        battery4_1
      )

      (
        (3.301 -0.3305 0.344)
        battery4_2
      )

      (
        (3.901 -0.3305 0.344)
        battery4_3
      )

      (
        (3.301 -0.8305 0.744)
        battery4_4
      )

      (
        (3.901 -0.8305 0.744)
        battery4_5
      )

      (
        (3.301 -0.3305 0.744)
        battery4_6
      )

      (
        (3.901 -0.3305 0.744)
        battery4_7
      )

      (
        (3.301 0.3305 0.344)
        battery5_0
      )

      (
        (3.901 0.3305 0.344)
        battery5_1
      )

      (
        (3.301 0.8305 0.344)
        battery5_2
      )

      (
        (3.901 0.8305 0.344)
        battery5_3
      )

      (
        (3.301 0.3305 0.744)
        battery5_4
      )

      (
        (3.901 0.3305 0.744)
        battery5_5
      )

      (
        (3.301 0.8305 0.744)
        battery5_6
      )

      (
        (3.901 0.8305 0.744)
        battery5_7
      )
    ); 	// ((0.5399 -0.5405 0.2005) pallet)// Whether any faceZones (as specified in the refinementSurfaces)// are only on the boundary of corresponding cellZones or also allow// free-standing zone faces. Not used if there are no faceZones.
  allowFreeStandingZoneFaces no;
} 	// Settings for the snapping.

snapControls
{
  nSmoothPatch 3;
  tolerance 1.0; 	//- Number of patch smoothing iterations before finding correspondence//  to surface//- Relative distance for points to be attracted by surface feature point//  or edge. True distance is this factor times local//  maximum edge length.//- Number of mesh displacement relaxation iterations.
  nSolveIter 30; 	//- Maximum number of snapping relaxation iterations. Should stop//  before upon reaching a correct mesh.
  nRelaxIter 5; 	//- Highly experimental and wip: number of feature edge snapping//  iterations. Leave out altogether to disable.//  Of limited use in this case since faceZone faces not handled.
  nFeatureSnapIter 10;
} 	// Settings for the layer addition.

addLayersControls
{
  relativeSizes yes;
  layers
  {
  } 	// Per final patch (so not geometry!) the layer information// Expansion factor for layer mesh
  expansionRatio 1.4; 	// Wanted thickness of final added cell layer. If multiple layers// is the thickness of the layer furthest away from the wall.// Relative to undistorted size of cell outside layer.// See relativeSizes parameter.
  finalLayerThickness 1.1; 	// Minimum thickness of cell layer. If for any reason layer// cannot be above minThickness do not add layer.// Relative to undistorted size of cell outside layer.
  minThickness 0.1; 	// If points get not extruded do nGrow layers of connected faces that are// also not grown. This helps convergence of the layer addition process// close to features.// Note: changed(corrected) w.r.t 1.7.x! (didn't do anything in 1.7.x)
  nGrow 0; 	// Advanced settings// When not to extrude surface. 0 is flat surface, 90 is when two faces// are perpendicular
  featureAngle 130; 	// Maximum number of snapping relaxation iterations. Should stop// before upon reaching a correct mesh.
  nRelaxIter 3; 	// Number of smoothing iterations of surface normals
  nSmoothSurfaceNormals 1; 	// Number of smoothing iterations of interior mesh movement direction
  nSmoothNormals 3; 	// Smooth layer thickness over surface patches
  nSmoothThickness 2; 	// Stop layer growth on highly warped cells
  maxFaceThicknessRatio 0.5; 	// Reduce layer growth where ratio thickness to medial// distance is large
  maxThicknessToMedialRatio 1; 	// Angle used to pick up medial axis points// Note: changed(corrected) w.r.t 1.7.x! 90 degrees corresponds to 130// in 1.7.x.
  minMedialAxisAngle 90; 	// Create buffer region for new layer terminations
  nBufferCellsNoExtrude 0; 	// Overall max number of layer addition iterations. The mesher will exit// if it reaches this number of iterations; possibly with an illegal// mesh.
  nLayerIter 50;
} 	// Generic mesh quality settings. At any undoable phase these determine// where to undo.

meshQualityControls
{
#include "meshQualityDict"
  nSmoothScale 4; 	// Advanced//- Number of error distribution iterations//- Amount to scale back displacement at error points
  errorReduction 0.75;
} 	// Advanced// Merge tolerance. Is fraction of overall bounding box of initial mesh.// Note: the write tolerance needs to be higher than this.

mergeTolerance 1e-06; 	// ************************************************************************* //

